# 手写 RPC 框架（简易版）

基于 Vert.x 构建服务器，创建 Web 请求。

Vert.x 官方文档：https://vertx.io/

### 1. common 模块
> 公共组件：定义了 User 实体类与 UserService 接口，供服务提供方（provide）实现。

需要同时被消费者于服务提供者引入，主要是编写和服务相关的接口和数据模型。

### 2. consumer 模块
> 服务消费者：真实发送请求（调用服务）的模块。

### 3. provide 模块
> 服务提供者：实现 common 公共模块中的 UserService 接口，供 consumer 服务消费者调用。

### 4. xiang-rpc-easy 模块
> 简易版 RPC 框架：Web 服务器。
> 
要让服务提供者提供可以远程访问的服务。就需要一个服务器，能够接收处理请求并返回响应。

本地服务注册器（LocalRegistry）使用线程安全的 ConcurrentHashMap 存储服务信息，key（服务名称）、value（服务实现类（.class））。
根据要调用的服务名称获取到对应的实现类，之后利用反射进行调用即可。

- 注册中心：侧重于管理注册的服务、提供服务信息给消费者（调用者）；
- 本地服务注册器：根据服务名称获取到对应的实现类，是完成调用不可或缺的模块；

**tip：**
服务注册完成之后就可以通过实现类调用了，调用之前需要实现序列化模块，因为在请求和响应中都会包含参数的传输。在网络中进行传输参数需要进行序列化与反序列化。

### 5. 通过代理发送调用
首先调用之前需要获取到具体的实现类，实现类总不能直接 cv 吧，这样 RPC 还有什么作用？

可以使用代理，通过生成代理对象来简化消费者的调用。

#### 静态代理（灵活性：差）
是指为每一个特定的类型的接口或者对象，编写一个代理类。
适用于需要代理的方法比较少时使用。
缺点：需要对每个需要的服务接口都写一个实现类，灵活性很差。

#### 动态代理
作用是根据要生成的对象的类型，自动生成一个代理对象。

- JDK 动态代理：简单易用、无需依赖其他库、性能高，缺点是只能对接口进行代理。
- CGLIB 动态代理：更灵活、可以对任何类进行代理、性能稍差与 JDK 动态代理。


### 6. 启动

1. 启动 `provider` 服务提供者；
2. 在 `consumer` 中的 `EasyConsumerExample` 方法进行调用（动态 / 静态）；

### 2.0 - 根据读取配置文件启动项目
### 启动方法：
1. 在服务消费者中的配置文件中编写配置信息。
2. 启动服务消费者中的 `ProviderExample` 即可。